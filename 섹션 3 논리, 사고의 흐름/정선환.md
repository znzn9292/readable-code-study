**"코드는 작성하고 난 순간부터 레거시다"**

우리는 새로운 코드의 쓰기보다 읽기의 시간 비율이 압도적으로 높다. 더 나은 소프트웨어를 만들고 더 나은 협업을 하기 위해서 코드를 작성할 때는 나만을 위한 쓰기 코드가 아닌 읽기를 기반하여 작성 하는 것도 중요하다. 

미래의 나, 미래의 나의 동료들을 위해 공부하고 기록한다.

---

# 1. 논리적 사고

## 1.1 인지적 경제성
추상화를 통해 데이터를 효율적으로 이해하고 기억하는데 이 기억은 최소한의 인지 정보로 최대 효과를 낸다.
효율적인 기억을 위해 범주화를 통해 대상을 추상화한다.
인지적 경제성은 최소한의 인지 정보로 최대 효율을 내는 것이므로 코드 작성 시 인지적 경제성을 추구하는 것이 중요하다.


# 2. Eearly Return

함수나 메서드에서 특정 조건을 만족할 때 함수를 즉시 종료하고 반환값을 처리하는 프로그래밍 기법이다. 조건이 만족되지 않으면 굳이 함수의 나머지 부분을 실행하지 않고, 가능한 빨리 반환하는 것을 목표로 한다.

```java
// 수정 전
if(a > 3) {
	doSomeThing1();
}else if (a <= 3 && b > 1) {
	doSomeThing2();
} else {
	doSomeThing3();
}

// 수정 후
void extracted() {
	if(a > 3) {
		doSomething1();
		return;
  	}
  	if( a<= 3 && b > 1) {
      doSomeThing2();
      return;
	}
  	doSomeThing3();
}
```

* Early Return 사용으로 `if-else` 사용을 지양
* `Switch Case` 사용도 고려해 볼 것

# 3. Depth 줄이기
사고의 Depth를 줄이기 위해 메소드를 추출하고 그 결과를 기반으로 분기문을 만듬으로써 사고 과정에서 메소드의 추상화를 통해 복잡도를 줄인다.

```java
// 수정 전
for(int i = 0; i < 20; i++) {
	for(int j = 20; i < 30; j++) {
		if(i >= 10 && j < 25) {
			dosomthing();
		}
	}
}

// 수정 후
for(int o = 0; i < 20; i++) {
	doSomthingWithI();
}
private void doSomthingWithI(int i) {
	for(int j = 20; j < 30; j++) {
	doSomthingWithIJ(i, j);
}
private void doSomthingWithIJ(int i, int j) {
	if(i>= 10 && j < 25) {
	doSomeThing() 
}
```
* `i`와 `j`의 연관성을 제거하여 메모리에서 기억된 사고를 더 효율적으로 활용한다.

> ❗️ **'무조건 1depth로 만들어라'** 가 아니라.
> 👉 보이는 Depth를 줄이는 데에 급급한 것이 아니라, 추상화를 통한 사고 과정의 Depth를 줄이는 것이 중요
> 👉 2중 중첩구조로 표현하는 것이 사고하는데에 더 도움이 된다고 판단한다면, 메서드 분리보다 그대로 놔두는 것이 더 나은 선택일 수 있다.

# 4. 공백라인을 대하는 자세

공박라인도 의미를 가진다.
-> 복잡한로직의 의미단위를 나누어 보여줌으로써 읽는 사람에게 추가적인 정보를 전달할 수 있다.

---
부정어를 대하는 자세
if(!isLeftDirection()) {
dosomething();
}

아래로

if(isRightDirection()0 {
doSomething();
}

if(isNotLeftDirection()) {
dosomething();
}

부정어구를 쓰지않아도 되는 상황인지 ㅊ ㅔ크

부정의 의미를 담은 다른 단어가 존재하는지 고민 or 부정어구로 메서드명 구성 -> 부정연산자(!)는 가독성을 감소

---

해피케이스와 예외처리
1. 예외가 발생할 가능성 낮추기
2. 어떤 값을 검증이 필요한 부분은 주로 외부 세계와의 접점
	-> 사용자입력, 객체 생성자, 외부서버의 요청 등
    
3. 의도한 예외와 예산하지 못한 예외를 구분하기
	-> 사용자에게 보여줄 예외와 개발자가 보고 처리해야할 예외구분

Null을 대하는 자세
1. 항상 NullPointException을 방지하는 방향으로 경각심 가지기
2. 메서드 설계 시 return null을 자제한다.
	-> 어렵다면, Optional 사용을 고민해본다.


> Optional에 관하여
-> Optional은 비싼 객체다 꼭 필요한 상황에서 반환 타입에 사용한다.
-> Optional을 파라미터로 받지 않도록한다. 분기 케이스가 3개나 된다.
-> Optional을 반환받았다면 최대한 빠르게 해소한다.

Optional을 해소하는 방법
-> 분기문을 만드는 isPresent()-get() 대신 풍부한 API 사용
ex) orElseGet(), orElseThrow(), ifPresent(), ifPresentOrElse()

-> orElse(), orElseGet, orElseThrow() 차이 숙지

